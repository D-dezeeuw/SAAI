---
import Layout from '../layouts/Layout.astro';
---

<Layout title="SAAI - Strudel Augmented Artificial Intelligence">
  <!-- Background visualizations (bottom to top: spectrum, scope, pianoroll, shader) -->
  <div class="viz-background">
    <canvas id="spectrum-canvas"></canvas>
    <canvas id="scope-canvas"></canvas>
    <canvas id="pianoroll-canvas"></canvas>
    <canvas id="shader-canvas"></canvas>
  </div>

  <!-- Sticky header -->
  <header class="header">
    <h1 title="Strudel Augmented Artificial Intelligence">SAAI</h1>
    <div class="header-controls">
      <button id="ai-btn" class="active" title="AI Generate">✦</button>
      <button id="code-btn" title="Code Editor" class="active">&lt;/&gt;</button>
      <button id="alter-toggle-btn" title="Alter Code" class="active">⚙</button>
      <span class="header-divider"></span>
      <button id="audio-viz-btn" title="Audio Visualizers" class="active">〰</button>
      <div class="viz-selector">
        <button id="viz-btn" title="Background Effects" class="active">◎</button>
        <div id="viz-dropdown" class="viz-dropdown hidden">
          <button data-viz="none">No vis</button>
          <button data-viz="orbs" class="active">Glowing Orbs</button>
          <button data-viz="stars">Stars</button>
          <button data-viz="trails">Flowing Trails</button>
        </div>
      </div>
      <span class="header-divider"></span>
      <button id="share-btn" title="Share Code">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"/>
          <polyline points="16 6 12 2 8 6"/>
          <line x1="12" y1="2" x2="12" y2="15"/>
        </svg>
      </button>
    </div>
  </header>

  <!-- UI on top -->
  <div class="container">
    <div id="generate-panel" class="generate-panel">
      <div class="input-section">
        <div class="input-group">
          <select id="genre-select">
            <option value="">No genre template</option>
            <option value="edm">EDM / House / Techno</option>
            <option value="dnb">Drum & Bass</option>
            <option value="hiphop-trap">Hip-Hop / Trap</option>
            <option value="acid">Acid</option>
            <option value="jazz">Jazz</option>
          </select>
          <select id="bank-select">
            <option value="" selected>Drum kit</option>
            <option value="RolandTR909">Roland TR-909</option>
            <option value="RolandTR808">Roland TR-808</option>
            <option value="RolandTR707">Roland TR-707</option>
            <option value="LinnDrum">LinnDrum</option>
            <option value="AkaiLinn">Akai Linn</option>
            <option value="KorgM1">Korg M1</option>
            <option value="AlesisHR16">Alesis HR16</option>
          </select>
          <input
            type="text"
            id="prompt-input"
            placeholder="Describe the music you want... (e.g., 'funky drum beat with hi-hats')"
          />
          <button id="generate-btn">Generate</button>
        </div>
      </div>

      <div class="context-section hidden" id="context-section">
        <div class="context-header" id="context-header">
          <span>✦ AI Context</span>
          <span class="context-arrow collapsed" id="context-arrow">▼</span>
        </div>
        <pre id="context-display" class="collapsed"></pre>
      </div>
    </div>

    <div class="code-section">
      <div id="code-editor-container">
        <button id="stop-btn" title="Reset">↺</button>
        <button id="play-btn" title="Play">▶</button>
      </div>
    </div>
    <div class="alter-section">
        <input
          type="text"
          id="alter-input"
          placeholder="Alter: e.g., 'add more reverb', 'make it faster', 'remove hi-hats'..."
        />
        <button id="alter-btn">Go!</button>
        <button id="evolve-btn" title="Auto">✧</button>
        <button id="alter-play-btn" class="alter-play-btn hidden" title="Play/Pause (K)">▶</button>
      </div>

  </div>

  <!-- Bottom-left buttons -->
  <div class="bottom-left-btns">
    <button id="info-btn" class="info-btn" title="Keyboard Shortcuts">
      <span>i</span>
    </button>
    <button id="stats-btn" class="stats-btn" title="Token Usage">
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>
      </svg>
    </button>
  </div>

  <!-- Shortcuts popup -->
  <div id="shortcuts-popup" class="shortcuts-popup hidden">
    <div class="shortcuts-header">
      <span>Info</span>
      <button id="shortcuts-close" class="shortcuts-close">&times;</button>
    </div>
    <div class="shortcuts-list">
      <span class="shortcuts-header">Keyboard Shortcuts</span>
      <div class="shortcut-item">
        <kbd>K</kbd>
        <span>Play / Stop</span>
      </div>
      <div class="shortcut-item">
        <kbd>H</kbd>
        <span>Hide / Show UI</span>
      </div>
      <div class="shortcut-item">
        <kbd>V</kbd>
        <span>Toggle Visualizers</span>
      </div>
      <div class="shortcut-item">
        <kbd>B</kbd>
        <span>Toggle Background</span>
      </div>
      <div class="shortcut-item">
        <kbd>A</kbd>
        <span>Toggle Visuals Only</span>
      </div>
      <div class="shortcut-item">
        <kbd>&lt;</kbd>
        <span>Previous Background</span>
      </div>
      <div class="shortcut-item">
        <kbd>&gt;</kbd>
        <span>Next Background</span>
      </div>
    </div>
    <div class="shortcuts-footer">
      <span>Dan de Zeeuw - Neko Media</span>
      <a href="https://github.com/D-dezeeuw/SAAI" target="_blank" rel="noopener noreferrer" class="github-link" title="View on GitHub">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
          <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
        </svg>
      </a>
    </div>
  </div>

  <!-- Token usage popup -->
  <div id="token-popup" class="token-popup hidden">
    <div class="token-popup-header">
      <span>Token Usage</span>
      <button id="token-popup-close" class="shortcuts-close">&times;</button>
    </div>
    <div class="token-popup-content">
      <div class="token-stat-row">
        <span class="token-stat-label">Input Tokens</span>
        <span id="token-input-display" class="token-stat-value">0</span>
      </div>
      <div class="token-stat-row">
        <span class="token-stat-label">Output Tokens</span>
        <span id="token-output-display" class="token-stat-value">0</span>
      </div>
      <div class="token-stat-row total">
        <span class="token-stat-label">Estimated Cost</span>
        <span id="token-cost-display" class="token-stat-value">$0.0000</span>
      </div>
    </div>
    <div class="token-popup-footer">
      <button id="reset-tokens" class="reset-tokens-btn">Reset Counters</button>
    </div>
  </div>

  <!-- Toast notification -->
  <div id="toast" class="toast hidden">Strudel is inedible :(</div>

  <script>
    import { initStrudel, evaluate, hush, getAudioContext, getAnalyserById } from '@strudel/web';
    import { cleanupDraw, Framer } from '@strudel/draw';
    import { createEditor, getCode, setCode, updateHighlights, clearHighlights, updateSliderWidgets, updateWidgets } from '../lib/editor';
    import { sliderWithID, slider } from '@strudel/codemirror';
    import type { EditorView } from '@codemirror/view';
    import { initShader, updateShader, setShaderStyle, setShaderIdle, cleanupShader, startShader, type ShaderContext, type AudioData } from '../lib/shader';
    import { CustomScope } from '../lib/customScope';
    import { CustomSpectrum } from '../lib/customSpectrum';
    import { APP_CONFIG } from '../lib/appConfig';
    import { getCodeFromUrl, generateShareUrl, clearCodeFromUrl } from '../lib/urlShare';

    // Make slider functions available globally for evaluated code
    // These are needed by the transpiler which converts slider() to sliderWithID()
    (window as any).sliderWithID = sliderWithID;
    (window as any).slider = slider;

    // Declare global functions made available by initStrudel
    declare function samples(source: string): Promise<void>;
    // Debug flag for highlighting
    declare global {
      interface Window {
        __debuggedHap?: boolean;
        sliderWithID?: typeof sliderWithID;
        slider?: typeof slider;
        __shaderCtx?: ShaderContext;
      }
    }

    // DOM elements
    const aiBtn = document.getElementById('ai-btn') as HTMLButtonElement;
    const codeBtn = document.getElementById('code-btn') as HTMLButtonElement;
    const alterToggleBtn = document.getElementById('alter-toggle-btn') as HTMLButtonElement;
    const generatePanel = document.getElementById('generate-panel') as HTMLDivElement;
    const codeSection = document.querySelector('.code-section') as HTMLDivElement;
    const alterSection = document.querySelector('.alter-section') as HTMLDivElement;
    const contextHeader = document.getElementById('context-header') as HTMLDivElement;
    const contextArrow = document.getElementById('context-arrow') as HTMLSpanElement;
    const contextSection = document.getElementById('context-section') as HTMLDivElement;
    const promptInput = document.getElementById('prompt-input') as HTMLInputElement;
    const genreSelect = document.getElementById('genre-select') as HTMLSelectElement;
    const bankSelect = document.getElementById('bank-select') as HTMLSelectElement;
    const generateBtn = document.getElementById('generate-btn') as HTMLButtonElement;
    const alterInput = document.getElementById('alter-input') as HTMLInputElement;
    const alterBtn = document.getElementById('alter-btn') as HTMLButtonElement;
    const evolveBtn = document.getElementById('evolve-btn') as HTMLButtonElement;
    const playBtn = document.getElementById('play-btn') as HTMLButtonElement;
    const alterPlayBtn = document.getElementById('alter-play-btn') as HTMLButtonElement;
    const stopBtn = document.getElementById('stop-btn') as HTMLButtonElement;
    const editorContainer = document.getElementById('code-editor-container') as HTMLDivElement;
    const contextDisplay = document.getElementById('context-display') as HTMLPreElement;
    const pianorollCanvas = document.getElementById('pianoroll-canvas') as HTMLCanvasElement;
    const spectrumCanvas = document.getElementById('spectrum-canvas') as HTMLCanvasElement;
    const scopeCanvas = document.getElementById('scope-canvas') as HTMLCanvasElement;
    const shaderCanvas = document.getElementById('shader-canvas') as HTMLCanvasElement;
    const vizBtn = document.getElementById('viz-btn') as HTMLButtonElement;
    const vizDropdown = document.getElementById('viz-dropdown') as HTMLDivElement;
    const vizButtons = vizDropdown.querySelectorAll('button[data-viz]') as NodeListOf<HTMLButtonElement>;
    const audioVizBtn = document.getElementById('audio-viz-btn') as HTMLButtonElement;
    const logoElement = document.querySelector('.header h1') as HTMLElement;
    const toast = document.getElementById('toast') as HTMLDivElement;
    const shareBtn = document.getElementById('share-btn') as HTMLButtonElement;
    let currentVizStyle = APP_CONFIG.defaultBackgroundEffect; // Default style from config
    let audioVizEnabled = APP_CONFIG.audioVisualizersEnabled; // Audio visualizers state from config
    let customScope: CustomScope | null = null; // Custom scope visualizer instance
    let customSpectrum: CustomSpectrum | null = null; // Custom spectrum visualizer instance

    // Mobile detection - use lighter visualizers on mobile
    const isMobile = window.matchMedia('(max-width: 768px)').matches;

    // Check for shared code in URL, otherwise use default
    const sharedCode = getCodeFromUrl();
    const exampleCode = sharedCode || APP_CONFIG.defaultCode;
    if (sharedCode) {
      clearCodeFromUrl(); // Clean URL after extracting code
    }

    // Debounce timer for code changes
    let codeChangeTimer: ReturnType<typeof setTimeout> | null = null;

    // Show toast notification
    function showToast(message: string = 'Strudel is inedible :(', duration: number = 2000) {
      console.log('[showToast] Showing toast:', message, 'toast element:', toast);
      toast.textContent = message;
      toast.classList.remove('hidden', 'fade-out');

      setTimeout(() => {
        toast.classList.add('fade-out');
        setTimeout(() => {
          toast.classList.add('hidden');
          toast.classList.remove('fade-out');
        }, 300); // Match animation duration
      }, duration);
    }

    // Handle code changes - hot-swap the pattern without restarting
    async function handleCodeChange() {
      if (!isPlaying) return;

      // Clear any pending timer
      if (codeChangeTimer) {
        clearTimeout(codeChangeTimer);
      }

      // Debounce the evaluation to avoid rapid re-evaluations while typing
      codeChangeTimer = setTimeout(async () => {
        await updatePattern();
      }, 200);
    }

    // Hot-swap the pattern without stopping the scheduler
    async function updatePattern() {
      const code = getCode(editor).trim();
      if (!code) return;

      // Check for and load any missing samples
      await ensureSamplesLoaded(code);

      // Add .analyze('viz') if needed (same logic as playCode)
      const alreadyHasAnalyze = /\.analyze\s*\(\s*['"]viz['"]\s*\)/.test(code);

      let vizCode: string;
      if (alreadyHasAnalyze) {
        codeOffset = 0;
        vizCode = code;
      } else {
        const hasMultipleStatements = /^(setbpm|setcps|setBpm|setCps)\s*\(/m.test(code);
        if (hasMultipleStatements) {
          codeOffset = 0;
          vizCode = code.replace(/(\)\s*)$/, `$1.analyze('viz')`);
        } else {
          codeOffset = 1;
          vizCode = `(${code}).analyze('viz')`;
        }
      }

      try {
        const result = await evaluate(vizCode);

        if (!result) {
          editorContainer.classList.add('error');
          showToast();
          return;
        }

        // Code is valid - remove error state
        editorContainer.classList.remove('error');

        // Update widgets if any - widgets are stored in strudelRepl.state, not in result
        // Adjust positions by codeOffset since widgets have positions from wrapped code
        const widgets = strudelRepl?.state?.widgets;
        if (widgets?.length > 0) {
          const adjustedWidgets = widgets.map((w: any) => ({
            ...w,
            from: w.from - codeOffset,
            to: w.to - codeOffset,
          }));
          const sliders = adjustedWidgets.filter((w: any) => w.type === 'slider');
          const blockWidgets = adjustedWidgets.filter((w: any) => w.type !== 'slider');
          if (sliders.length > 0) updateSliderWidgets(editor, sliders);
          if (blockWidgets.length > 0) updateWidgets(editor, blockWidgets);
        }
      } catch (error) {
        console.error('Pattern update error:', error);
        editorContainer.classList.add('error');
        showToast();
      }
    }

    // Set default values from config
    promptInput.value = APP_CONFIG.defaultPrompt;
    genreSelect.value = APP_CONFIG.defaultGenre;
    bankSelect.value = APP_CONFIG.defaultDrumKit;

    // Update viz dropdown to match default background effect
    vizButtons.forEach(btn => {
      btn.classList.toggle('active', btn.dataset.viz === APP_CONFIG.defaultBackgroundEffect);
    });

    // Initialize CodeMirror editor with change handler
    const editor: EditorView = createEditor(editorContainer, exampleCode, handleCodeChange);

    // State
    let isInitialized = false;
    let isPlaying = false;
    let isPaused = false;
    let strudelRepl: any = null;
    let highlightFramer: InstanceType<typeof Framer> | null = null;
    let lastEnrichedContext: string = '';
    let lastGenreContext: string = '';
    let lastBankName: string = '';
    let codeOffset: number = 0; // Offset for location mapping when code is wrapped
    let isEvolving: boolean = false;
    let evolveInterval: ReturnType<typeof setInterval> | null = null;

    // Token tracking state
    let tokenTotals = {
      totalInputTokens: 0,
      totalOutputTokens: 0
    };

    // Pricing constants (per million tokens)
    const INPUT_COST_PER_M = 0.50;
    const OUTPUT_COST_PER_M = 3.00;

    // Token tracking helper functions
    function updateTokenTotals(usage: { promptTokens: number; completionTokens: number }) {
      tokenTotals.totalInputTokens += usage.promptTokens;
      tokenTotals.totalOutputTokens += usage.completionTokens;
      updateTokenDisplay();
    }

    function calculateCost(): number {
      const inputCost = (tokenTotals.totalInputTokens / 1_000_000) * INPUT_COST_PER_M;
      const outputCost = (tokenTotals.totalOutputTokens / 1_000_000) * OUTPUT_COST_PER_M;
      return inputCost + outputCost;
    }

    function formatTokenCount(count: number): string {
      if (count >= 1_000_000) return (count / 1_000_000).toFixed(2) + 'M';
      if (count >= 1_000) return (count / 1_000).toFixed(1) + 'K';
      return count.toString();
    }

    function updateTokenDisplay() {
      const tokenInputDisplay = document.getElementById('token-input-display');
      const tokenOutputDisplay = document.getElementById('token-output-display');
      const tokenCostDisplay = document.getElementById('token-cost-display');
      if (tokenInputDisplay) {
        tokenInputDisplay.textContent = formatTokenCount(tokenTotals.totalInputTokens);
      }
      if (tokenOutputDisplay) {
        tokenOutputDisplay.textContent = formatTokenCount(tokenTotals.totalOutputTokens);
      }
      if (tokenCostDisplay) {
        tokenCostDisplay.textContent = `$${calculateCost().toFixed(4)}`;
      }
    }

    function resetTokenTotals() {
      tokenTotals = { totalInputTokens: 0, totalOutputTokens: 0 };
      updateTokenDisplay();
    }

    // We'll use Strudel's built-in analyser system by adding .analyze() to patterns
    // The analyser is stored in superdough's `analysers` object, accessible via getAnalyserById

    // Base samples from dirt-samples and other sources
    const BASE_SAMPLES = new Set([
      // Drums (dirt-samples)
      'bd', 'sd', 'hh', 'oh', 'cp', 'cr', 'rim', 'tom', 'lt', 'mt', 'ht',
      'perc', 'tabla', 'tabla2', 'hand', 'kick', 'snare',
      // Percussion (dirt-samples)
      'can', 'metal', 'bottle', 'glass', 'crow', 'jazz', 'east',
      'world', 'mouth', 'click', 'noise',
      // Melodic samples (dirt-samples)
      'arpy', 'pluck', 'jvbass', 'bass', 'bass1', 'bass2', 'bass3',
      'casio', 'gtr', 'ades', 'ade',
      // Built-in WebAudio synths (used with note().s())
      'sawtooth', 'square', 'triangle', 'sine',
      'supersaw', 'supersquare', 'supersine',
      // Loaded sample instruments (dough-samples)
      'piano'
    ]);
    const loadedSamples = new Set<string>(BASE_SAMPLES);

    // Extract sample names from Strudel code
    function extractSamplesFromCode(code: string): string[] {
      const foundSamples = new Set<string>();

      // Match s("..."), sound("..."), and .s("...") patterns
      const patterns = [
        /s\("([^"]+)"\)/g,
        /sound\("([^"]+)"\)/g,
        /\.s\("([^"]+)"\)/g
      ];

      for (const pattern of patterns) {
        let match;
        while ((match = pattern.exec(code)) !== null) {
          // Parse mini-notation: "bd:5 ~ [sd,cp] hh*8" → ["bd", "sd", "cp", "hh"]
          const names = match[1]
            .replace(/[\[\]<>]/g, ' ')      // Remove brackets
            .replace(/[*\/]\d+\.?\d*/g, '') // Remove *8, /2, *0.5 etc
            .replace(/:\d+/g, '')           // Remove :5 variants
            .replace(/[~,]/g, ' ')          // Replace ~ and , with space
            .split(/\s+/)
            .filter(s => s.length > 0 && s !== '~');

          names.forEach(n => foundSamples.add(n));
        }
      }

      return Array.from(foundSamples);
    }

    // Ensure all samples used in code are loaded
    async function ensureSamplesLoaded(code: string): Promise<void> {
      const needed = extractSamplesFromCode(code);
      const missing = needed.filter(s => !loadedSamples.has(s));

      if (missing.length > 0) {
        // Samples from dirt-samples should already be available after init
        // Just mark them as known so we don't warn again
        missing.forEach(s => loadedSamples.add(s));
      }
    }

    // Setup canvas for full-viewport visualization
    function setupCanvas(canvas: HTMLCanvasElement): CanvasRenderingContext2D {
      const dpr = window.devicePixelRatio || 1;

      // Set to full viewport size
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;

      const ctx = canvas.getContext('2d')!;
      return ctx;
    }

    // Handle window resize - update canvas dimensions
    // Helper to create a color-forcing Proxy for scope canvas context
    const SCOPE_COLOR = '#FF00FF';
    const SCOPE_GLOW_INTENSITY = 25;
    const SCOPE_LINE_WIDTH = 2;
    function createScopeCtxProxy(ctx: CanvasRenderingContext2D) {
      return new Proxy(ctx, {
        set(target: any, prop: string, value: any) {
          if (prop === 'strokeStyle' || prop === 'shadowColor') {
            value = SCOPE_COLOR;
          }
          // Force thinner lines
          if (prop === 'lineWidth') {
            value = SCOPE_LINE_WIDTH;
          }
          // Add glow effect
          if (prop === 'strokeStyle') {
            target.shadowColor = SCOPE_COLOR;
            target.shadowBlur = SCOPE_GLOW_INTENSITY;
          }
          target[prop] = value;
          return true;
        },
        get(target: any, prop: string) {
          const value = target[prop];
          if (typeof value === 'function') {
            return value.bind(target);
          }
          return value;
        }
      });
    }

    function handleResize() {
      if ((window as any).__pianorollCtx) {
        (window as any).__pianorollCtx = setupCanvas(pianorollCanvas);
      }
      if ((window as any).__spectrumCtx) {
        (window as any).__spectrumCtx = setupCanvas(spectrumCanvas);
      }
      if ((window as any).__scopeCtx) {
        (window as any).__scopeCtx = createScopeCtxProxy(setupCanvas(scopeCanvas));
      }
      // Resize custom visualizers
      customScope?.resize();
      customSpectrum?.resize();
    }

    window.addEventListener('resize', handleResize);

    // Initialize Strudel with samples (loads all functions + drum samples)
    async function init() {
      if (isInitialized) return;
      try {
        strudelRepl = await initStrudel({
          // Load samples from multiple sources
          prebake: async () => {
            // Dirt-Samples for drums and percussion (includes 808oh for open hi-hat)
            await samples('github:tidalcycles/Dirt-Samples/master/');
            // Piano samples from dough-samples (Salamander Grand Piano)
            await samples('https://raw.githubusercontent.com/felixroos/dough-samples/main/piano.json');
            // Tidal drum machine samples (RolandTR909, RolandTR808, etc.) for .bank() function
            await samples('https://raw.githubusercontent.com/felixroos/dough-samples/main/tidal-drum-machines.json');
          },
        });
        isInitialized = true;
      } catch (error) {
        console.error('Init error:', error);
      }
    }

    // Convert note value to MIDI number
    function noteToMidi(note: any): number | null {
      if (typeof note === 'number') return note;
      if (typeof note === 'string') {
        // Parse note strings like "c3", "e4", "f#2"
        const match = note.match(/^([a-g])([#b]?)(-?\d+)$/i);
        if (match) {
          const noteNames: Record<string, number> = { c: 0, d: 2, e: 4, f: 5, g: 7, a: 9, b: 11 };
          const base = noteNames[match[1].toLowerCase()];
          const modifier = match[2] === '#' ? 1 : match[2] === 'b' ? -1 : 0;
          const octave = parseInt(match[3]);
          return (octave + 1) * 12 + base + modifier;
        }
      }
      return null;
    }

    // Extract audio data from haps for shader visualization
    function extractAudioData(haps: any[], now: number): AudioData {
      // Filter to active haps only
      const activeHaps = haps.filter((h: any) => {
        const start = h.whole?.begin ?? h.part?.begin ?? 0;
        const end = h.whole?.end ?? h.part?.end ?? 0;
        return now >= start && now < end;
      });

      let bassCount = 0;
      let trebleCount = 0;

      // Analyze note frequencies
      for (const hap of activeHaps) {
        const noteVal = hap.value?.note ?? hap.value?.n;
        if (noteVal !== undefined) {
          const midi = noteToMidi(noteVal);
          if (midi !== null) {
            if (midi < 48) bassCount++;      // Below C3
            if (midi > 72) trebleCount++;    // Above C5
          }
        }
        // Drum samples count as bass
        const sample = hap.value?.s;
        if (sample && (sample === 'bd' || sample.startsWith('bd:'))) {
          bassCount++;
        }
      }

      return {
        intensity: Math.min(activeHaps.length / 8, 1),
        bass: Math.min(bassCount / 3, 1),
        treble: Math.min(trebleCount / 3, 1),
        time: now
      };
    }

    // Draw pianoroll visualization
    // Options: playhead at 0.02 (2% from left), smear disabled
    const pianorollPlayhead = 0.09;
    const pianorollSmear = false;

    function drawPianoroll(ctx: CanvasRenderingContext2D, haps: any[], now: number, cycles: number) {
      const width = ctx.canvas.width;
      const height = ctx.canvas.height;
      const dpr = window.devicePixelRatio || 1;

      if (pianorollSmear) {
        // Smear effect: fade previous frame while keeping transparency
        ctx.globalCompositeOperation = 'destination-out';
        ctx.fillStyle = 'rgba(0, 0, 0, 0.12)';
        ctx.fillRect(0, 0, width, height);
        ctx.globalCompositeOperation = 'source-over';
      } else {
        // Clear canvas to transparent (so shader shows through)
        ctx.clearRect(0, 0, width, height);
      }

      // Collect note events and find range
      const noteEvents: { start: number; end: number; midi: number; active: boolean }[] = [];
      let minMidi = 127, maxMidi = 0;

      for (const hap of haps) {
        const noteVal = hap.value?.note ?? hap.value?.n ?? hap.value?.freq;
        if (noteVal === undefined) continue;

        let midi: number | null = null;
        if (hap.value?.freq) {
          // Convert frequency to MIDI
          midi = Math.round(12 * Math.log2(hap.value.freq / 440) + 69);
        } else {
          midi = noteToMidi(noteVal);
        }

        if (midi === null || midi < 0 || midi > 127) continue;

        const start = hap.whole?.begin ?? hap.part?.begin ?? 0;
        const end = hap.whole?.end ?? hap.part?.end ?? start + 0.25;
        const isActive = now >= start && now < end;

        noteEvents.push({ start, end, midi, active: isActive });
        minMidi = Math.min(minMidi, midi);
        maxMidi = Math.max(maxMidi, midi);
      }

      if (noteEvents.length === 0) return;

      // Add padding to range
      minMidi = Math.max(0, minMidi - 2);
      maxMidi = Math.min(127, maxMidi + 2);
      const midiRange = Math.max(maxMidi - minMidi, 12);

      // Time range - playhead position determines how much past/future is shown
      const timeStart = now - cycles * pianorollPlayhead;
      const timeEnd = now + cycles * (1 - pianorollPlayhead);
      const timeRange = timeEnd - timeStart;

      // Draw notes with glow effect
      const PIANOROLL_ACTIVE_COLOR = '#00FFFF';
      const PIANOROLL_INACTIVE_COLOR = '#155e75';
      const PIANOROLL_GLOW = 20;

      for (const event of noteEvents) {
        const x = ((event.start - timeStart) / timeRange) * width;
        const noteWidth = ((event.end - event.start) / timeRange) * width;
        const y = height - ((event.midi - minMidi) / midiRange) * height;
        const noteHeight = Math.max(height / midiRange, 3 * dpr);

        if (event.active) {
          // Active notes: bright cyan with strong glow
          ctx.shadowColor = PIANOROLL_ACTIVE_COLOR;
          ctx.shadowBlur = PIANOROLL_GLOW;
          ctx.fillStyle = PIANOROLL_ACTIVE_COLOR;
        } else {
          // Inactive notes: dimmer cyan with subtle glow
          ctx.shadowColor = PIANOROLL_INACTIVE_COLOR;
          ctx.shadowBlur = PIANOROLL_GLOW / 3;
          ctx.fillStyle = PIANOROLL_INACTIVE_COLOR;
        }
        ctx.fillRect(x, y - noteHeight / 2, Math.max(noteWidth, 2 * dpr), noteHeight);
      }

      // Reset shadow for playhead
      ctx.shadowBlur = 0;

      // Draw playhead line at playhead position
      const playheadX = pianorollPlayhead * width;
      ctx.strokeStyle = 'rgba(236, 72, 153, 0.5)';
      ctx.lineWidth = 2 * dpr;
      ctx.beginPath();
      ctx.moveTo(playheadX, 0);
      ctx.lineTo(playheadX, height);
      ctx.stroke();
    }

    // Start mini-notation highlighting and pianoroll
    function startHighlighting() {
      if (!strudelRepl?.scheduler) return;

      highlightFramer?.stop();
      const pianorollCtx = (window as any).__pianorollCtx as CanvasRenderingContext2D;

      highlightFramer = new Framer(() => {
        if (!strudelRepl?.scheduler?.pattern) return;

        const now = strudelRepl.scheduler.now();

        // Query wider arc for pianoroll (4 cycles) - match playhead position
        const cycles = 4;
        const haps = strudelRepl.scheduler.pattern.queryArc(now - cycles * pianorollPlayhead, now + cycles * (1 - pianorollPlayhead));

        // Draw pianoroll
        if (pianorollCtx) {
          drawPianoroll(pianorollCtx, haps, now, cycles);
        }

        // Update shader with audio data
        if (window.__shaderCtx) {
          const audioData = extractAudioData(haps, now);
          updateShader(window.__shaderCtx, audioData);
        }

        // Filter active haps once (used for both logo glow and code highlighting)
        const activeHaps = haps.filter((hap: any) => {
          const start = hap.whole?.begin ?? hap.part?.begin ?? 0;
          const end = hap.whole?.end ?? hap.part?.end ?? 0;
          return now >= start && now < end;
        });

        // Update logo glow based on active notes (beat-reactive)
        if (logoElement) {
          // Weight by sound type - drums/bass get more weight
          let intensity = 0;
          for (const hap of activeHaps) {
            const sound = hap.value?.s || '';
            const note = hap.value?.note ?? hap.value?.n;
            // Bass drum and low notes get more weight
            if (sound === 'bd' || sound.includes('kick')) {
              intensity += 1.0;
            } else if (sound === 'sd' || sound === 'cp' || sound.includes('snare')) {
              intensity += 0.6;
            } else if (sound === 'hh' || sound === 'oh' || sound.includes('hat')) {
              intensity += 0.2;
            } else if (note !== undefined) {
              // Melodic notes - lower notes = more intensity
              const midi = typeof note === 'number' ? note : 60;
              intensity += midi < 50 ? 0.5 : 0.3;
            } else {
              intensity += 0.3;
            }
          }

          // Clamp and normalize
          intensity = Math.min(intensity, 2) / 2; // Max out at 2, normalize to 0-1

          // Map to glow - smaller & brighter at rest, larger & softer on beat
          const minGlow = 0;
          const maxGlow = 10;
          const glowSize = minGlow + intensity * (maxGlow - minGlow);
          // Invert opacity: brighter when small, softer when large
          const glowOpacity = 0.8 - intensity * 0.3;

          logoElement.style.filter = `drop-shadow(0 0 ${glowSize}px rgba(255, 255, 255, ${glowOpacity}))`;
        }

        // Extract locations from active haps for code highlighting
        const highlights: {from: number, to: number}[] = [];
        for (const hap of activeHaps) {
          // Debug: log hap structure (without JSON.stringify due to BigInt)
          if (activeHaps.length > 0 && !window.__debuggedHap) {
            window.__debuggedHap = true;
          }

          if (hap.context?.locations) {
            for (const loc of hap.context.locations) {
              // Handle both array [from, to] and object {start, end} formats
              // Subtract codeOffset to map back to editor positions
              if (Array.isArray(loc) && loc.length >= 2) {
                highlights.push({ from: loc[0] - codeOffset, to: loc[1] - codeOffset });
              } else if (loc && typeof loc === 'object' && 'start' in loc && 'end' in loc) {
                highlights.push({ from: loc.start - codeOffset, to: loc.end - codeOffset });
              }
            }
          }
        }

        updateHighlights(editor, highlights);
      }, (err:any) => console.warn('Highlight error:', err));

      highlightFramer.start();
    }

    function stopHighlighting() {
      highlightFramer?.stop();
      highlightFramer = null;
      clearHighlights(editor);
      window.__debuggedHap = false; // Reset debug flag for next play

      // Clear pianoroll canvas (transparent to show shader behind)
      const pianorollCtx = (window as any).__pianorollCtx as CanvasRenderingContext2D;
      if (pianorollCtx) {
        pianorollCtx.clearRect(0, 0, pianorollCtx.canvas.width, pianorollCtx.canvas.height);
      }

      // Clear scope canvas
      const scopeCtx = (window as any).__scopeCtx as CanvasRenderingContext2D;
      if (scopeCtx) {
        scopeCtx.clearRect(0, 0, scopeCtx.canvas.width, scopeCtx.canvas.height);
      }

      // Reset logo glow to minimal
      if (logoElement) {
        logoElement.style.filter = 'drop-shadow(0 0 2px rgba(255, 255, 255, 0.3))';
      }
    }


    async function generateCode() {
      const message = promptInput.value.trim();
      if (!message) {
        return;
      }

      // Stop any currently playing song before generating new code
      if (isPlaying || isPaused) {
        stopCode();
      }

      generateBtn.disabled = true;
      contextDisplay.textContent = 'Generating context...';
      contextDisplay.className = 'loading';
      setCode(editor, '// Generating...');

      // Fetch genre template if selected
      let genreContext = '';
      const selectedGenre = genreSelect.value;
      if (selectedGenre) {
        try {
          const genreResponse = await fetch(`/genres/strudel-${selectedGenre}-template.md`);
          if (genreResponse.ok) {
            genreContext = await genreResponse.text();
            lastGenreContext = genreContext;
          }
        } catch (e) {
          console.warn('Failed to load genre template:', e);
        }
      }

      // Get selected bank and store it for alter/evolve operations
      const bankName = bankSelect.value;
      lastBankName = bankName;

      try {
        const response = await fetch('/api/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ message, currentCode: getCode(editor), genreContext, bankName })
        });

        if (!response.ok || !response.body) {
          throw new Error('Failed to connect to API');
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || '';

          let eventType = '';
          for (const line of lines) {
            if (line.startsWith('event: ')) {
              eventType = line.slice(7);
            } else if (line.startsWith('data: ') && eventType) {
              const data = JSON.parse(line.slice(6));

              if (eventType === 'stage1') {
                lastEnrichedContext = data.enrichedPrompt;
                contextDisplay.textContent = data.enrichedPrompt;
                contextDisplay.className = '';
                showContextSection();
                setCode(editor, '// Generating code...');
              } else if (eventType === 'stage2') {
                setCode(editor, data.code);
              } else if (eventType === 'done') {
                if (data.usage) {
                  updateTokenTotals(data.usage);
                }
              } else if (eventType === 'error') {
                throw new Error(data.error);
              }
              eventType = '';
            }
          }
        }
      } catch (error) {
        const msg = error instanceof Error ? error.message : 'Unknown error';
        setCode(editor, `// Error: ${msg}`);
        contextDisplay.className = '';
      } finally {
        generateBtn.disabled = false;
      }
    }

    async function alterCode() {
      const alterRequest = alterInput.value.trim();
      if (!alterRequest) {
        return;
      }

      const currentCode = getCode(editor);
      if (!currentCode) {
        return;
      }

      alterBtn.disabled = true;
      alterBtn.textContent = '...';

      try {
        const response = await fetch('/api/alter', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            alterRequest,
            currentCode,
            enrichedContext: lastEnrichedContext,
            genreContext: lastGenreContext,
            bankName: lastBankName
          })
        });

        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.error || 'Alter failed');
        }

        setCode(editor, data.code);
        alterInput.value = '';

        // Track token usage
        if (data.usage) {
          updateTokenTotals(data.usage);
        }

      } catch (error) {
        console.error('Alter error:', error);
      } finally {
        alterBtn.disabled = false;
        alterBtn.textContent = 'Go!';
      }
    }

    async function evolveCode() {
      const currentCode = getCode(editor);
      if (!currentCode) {
        return;
      }

      try {
        const response = await fetch('/api/evolve', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            currentCode,
            enrichedContext: lastEnrichedContext,
            genreContext: lastGenreContext,
            bankName: lastBankName
          })
        });

        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.error || 'Evolution failed');
        }

        setCode(editor, data.code);

        // Track token usage
        if (data.usage) {
          updateTokenTotals(data.usage);
        }

      } catch (error) {
        console.error('Evolution error:', error);
      }
    }

    function toggleEvolution() {
      isEvolving = !isEvolving;
      evolveBtn.classList.toggle('active', isEvolving);

      if (isEvolving) {
        // Immediately trigger one evolution
        evolveCode();
        // Then continue every 10 seconds
        evolveInterval = setInterval(evolveCode, 10000);
      } else {
        if (evolveInterval) {
          clearInterval(evolveInterval);
          evolveInterval = null;
        }
      }
    }

    async function playCode() {
      const code = getCode(editor).trim();
      if (!code) {
        console.warn('[playCode] No code to play');
        return;
      }

      // Ensure Strudel is initialized
      if (!isInitialized) {
        await init();
      }

      // Check for and load any missing samples
      await ensureSamplesLoaded(code);

      // Setup visualization canvases
      (window as any).__pianorollCtx = setupCanvas(pianorollCanvas);
      (window as any).__spectrumCtx = setupCanvas(spectrumCanvas);

      // Wrap scope canvas context with a Proxy to force magenta color
      // This bypasses Strudel's bug that overwrites the config color
      (window as any).__scopeCtx = createScopeCtxProxy(setupCanvas(scopeCanvas));

      // Note: CustomScope uses window.__scopeAnalyser which is set by AudioContext interception

      // Initialize custom scope and spectrum only on desktop (skip on mobile for performance)
      if (!isMobile) {
        if (!customScope) {
          customScope = new CustomScope(scopeCanvas, {
            color: '#FF00FF',
            thickness: 3,
            scale: 0.25,
            pos: 0.5,
            align: true,
            glow: true,
            glowIntensity: 8
          });
        }

        if (!customSpectrum) {
          customSpectrum = new CustomSpectrum(spectrumCanvas, {
            color: '#00FFFF',
            speed: 1,
            min: -80,
            max: 0,
            thickness: 1,
            glow: true,
            glowIntensity: 5
          });
        }
      }

      // Initialize shader if not already running and a style is selected
      if (!window.__shaderCtx && currentVizStyle !== 'none') {
        try {
          window.__shaderCtx = initShader(shaderCanvas, currentVizStyle);
        } catch (e) {
          console.warn('Shader initialization failed:', e);
        }
      }

      // Ensure shader is running (it may have been stopped if set to 'none' previously)
      if (window.__shaderCtx && currentVizStyle !== 'none') {
        startShader(window.__shaderCtx);
      }

      // Add .analyze('viz') to create a Strudel analyser that both visualizers can use
      // Skip if code already has .analyze('viz')
      const alreadyHasAnalyze = /\.analyze\s*\(\s*['"]viz['"]\s*\)/.test(code);

      let vizCode: string;
      if (alreadyHasAnalyze) {
        // Code already has analyze, use as-is
        codeOffset = 0;
        vizCode = code;
      } else {
        // Check if code has multiple statements (setbpm, setcps, etc.)
        const hasMultipleStatements = /^(setbpm|setcps|setBpm|setCps)\s*\(/m.test(code);

        if (hasMultipleStatements) {
          // For multi-statement code, append .analyze() to the last expression
          codeOffset = 0;
          vizCode = code.replace(/(\)\s*)$/, `$1.analyze('viz')`);
        } else {
          // Single expression - wrap and add .analyze()
          codeOffset = 1;
          vizCode = `(${code}).analyze('viz')`;
        }
      }

      try {
        const result = await evaluate(vizCode);

        // evaluate() catches errors internally and returns undefined
        if (!result) {
          editorContainer.classList.add('error');
          showToast();
          return;
        }

        // Code is valid - remove error state
        editorContainer.classList.remove('error');

        // Get Strudel's analyser and make it available to our visualizers
        const strudelAnalyser = getAnalyserById('viz');
        if (strudelAnalyser) {
          window.__scopeAnalyser = strudelAnalyser;
          window.__scopeAudioContext = getAudioContext();
        } else {
          console.warn('[Visualizer] Strudel analyser not found');
        }

        // If widgets were found (sliders, etc.), render them in the editor
        // Widgets are stored in strudelRepl.state, not in result
        // Adjust positions by codeOffset since widgets have positions from wrapped code
        const widgets = strudelRepl?.state?.widgets;
        if (widgets?.length > 0) {
          const adjustedWidgets = widgets.map((w: any) => ({
            ...w,
            from: w.from - codeOffset,
            to: w.to - codeOffset,
          }));
          const sliders = adjustedWidgets.filter((w: any) => w.type === 'slider');
          const blockWidgets = adjustedWidgets.filter((w: any) => w.type !== 'slider');
          if (sliders.length > 0) updateSliderWidgets(editor, sliders);
          if (blockWidgets.length > 0) updateWidgets(editor, blockWidgets);
        }

        startHighlighting();
        // Start custom visualizers only on desktop and if enabled (they use window.__scopeAnalyser)
        if (!isMobile && audioVizEnabled) {
          customScope?.start();
          customSpectrum?.start();
        }
        isPlaying = true;
        isPaused = false;
        playBtn.textContent = '⏸';
        playBtn.title = 'Pause';
        playBtn.className = 'playing';
        syncAlterPlayBtn();
      } catch (error) {
        console.error('Play error:', error);
        editorContainer.classList.add('error');
        showToast();
      }
    }

    // Toggle play/stop
    function togglePlay() {
      if (isPaused) {
        // Resume from pause
        resumeCode();
      } else if (isPlaying) {
        // Pause playback
        pauseCode();
      } else {
        // Start playing
        playCode();
      }
    }

    function pauseCode() {
      if (isInitialized && isPlaying) {
        try {
          const audioCtx = getAudioContext();
          if (audioCtx && audioCtx.state === 'running') {
            audioCtx.suspend();
          }
        } catch (e) {
          console.warn('Could not suspend audio context:', e);
        }
        isPaused = true;
        isPlaying = false;
        playBtn.textContent = '▶';
        playBtn.title = 'Resume';
        playBtn.className = 'paused';
        syncAlterPlayBtn();
      }
    }

    function resumeCode() {
      if (isInitialized && isPaused) {
        try {
          const audioCtx = getAudioContext();
          if (audioCtx && audioCtx.state === 'suspended') {
            audioCtx.resume();
          }
        } catch (e) {
          console.warn('Could not resume audio context:', e);
        }
        isPaused = false;
        isPlaying = true;
        playBtn.textContent = '⏸';
        playBtn.title = 'Pause';
        playBtn.className = 'playing';
        syncAlterPlayBtn();
      }
    }

    function stopCode() {
      if (isInitialized) {
        // Resume audio context first if suspended (needed for clean stop)
        try {
          const audioCtx = getAudioContext();
          if (audioCtx && audioCtx.state === 'suspended') {
            audioCtx.resume();
          }
        } catch (e) {
          console.warn('Could not resume audio context:', e);
        }

        hush();
        cleanupDraw(true);
        stopHighlighting();
        customScope?.stop();
        customSpectrum?.stop();
        isPlaying = false;
        isPaused = false;
        playBtn.textContent = '▶';
        playBtn.title = 'Play';
        playBtn.className = '';
        syncAlterPlayBtn();

        // Set shader to idle mode (subtle animation)
        if (window.__shaderCtx) {
          setShaderIdle(window.__shaderCtx);
        }
      }
    }

    // Toggle generate panel visibility
    function toggleGeneratePanel() {
      const isVisible = !generatePanel.classList.contains('hidden');
      generatePanel.classList.toggle('hidden');
      aiBtn.classList.toggle('active', !isVisible);
    }

    // Toggle code section visibility
    function toggleCodeSection() {
      const isVisible = !codeSection.classList.contains('hidden');
      codeSection.classList.toggle('hidden');
      codeBtn.classList.toggle('active', !isVisible);
      updateAlterPlayBtnVisibility();
    }

    // Update alter play button visibility based on code section state
    function updateAlterPlayBtnVisibility() {
      const codeHidden = codeSection.classList.contains('hidden');
      const alterVisible = !alterSection.classList.contains('hidden');
      alterPlayBtn.classList.toggle('hidden', !(codeHidden && alterVisible));
    }

    // Sync alter play button state with main play button
    function syncAlterPlayBtn() {
      alterPlayBtn.textContent = playBtn.textContent;
      alterPlayBtn.className = 'alter-play-btn' + (playBtn.className.includes('playing') ? ' playing' : '') + (playBtn.className.includes('paused') ? ' paused' : '');
      if (codeSection.classList.contains('hidden') && !alterSection.classList.contains('hidden')) {
        alterPlayBtn.classList.remove('hidden');
      } else {
        alterPlayBtn.classList.add('hidden');
      }
    }

    // Toggle alter section visibility
    function toggleAlterSection() {
      const isVisible = !alterSection.classList.contains('hidden');
      alterSection.classList.toggle('hidden');
      alterToggleBtn.classList.toggle('active', !isVisible);
      updateAlterPlayBtnVisibility();
    }

    // Toggle context section visibility (only if there's content)
    function toggleContextSection() {
      if (!contextDisplay.textContent?.trim()) return;
      contextDisplay.classList.toggle('collapsed');
      contextArrow.classList.toggle('collapsed');
    }

    // Show context section when content is available
    function showContextSection() {
      contextSection.classList.remove('hidden');
    }

    // Toggle all panels (code + generate + alter)
    let panelsVisible = true;
    let savedCodeState = true;
    let savedGenerateState = true;
    let savedAlterState = true;

    function toggleAllPanels() {
      if (panelsVisible) {
        // Save current states before hiding
        savedCodeState = !codeSection.classList.contains('hidden');
        savedGenerateState = !generatePanel.classList.contains('hidden');
        savedAlterState = !alterSection.classList.contains('hidden');
        // Hide all
        codeSection.classList.add('hidden');
        generatePanel.classList.add('hidden');
        alterSection.classList.add('hidden');
        codeBtn.classList.remove('active');
        aiBtn.classList.remove('active');
        alterToggleBtn.classList.remove('active');
      } else {
        // Restore saved states
        if (savedCodeState) {
          codeSection.classList.remove('hidden');
          codeBtn.classList.add('active');
        }
        if (savedGenerateState) {
          generatePanel.classList.remove('hidden');
          aiBtn.classList.add('active');
        }
        if (savedAlterState) {
          alterSection.classList.remove('hidden');
          alterToggleBtn.classList.add('active');
        }
      }
      panelsVisible = !panelsVisible;
    }

    // Toggle background visualization between "none" and "orbs"
    function toggleBackgroundVis() {
      const newStyle = currentVizStyle === 'none' ? 'orbs' : 'none';

      // Update dropdown active state
      vizButtons.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.viz === newStyle);
      });
      currentVizStyle = newStyle;
      vizBtn.classList.toggle('active', newStyle !== 'none');

      if (newStyle === 'none') {
        // Cleanup shader
        if (window.__shaderCtx) {
          cleanupShader(window.__shaderCtx);
          window.__shaderCtx = undefined;
          const gl = shaderCanvas.getContext('webgl2');
          if (gl) {
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);
          }
        }
      } else {
        // Initialize or switch to orbs
        if (window.__shaderCtx) {
          setShaderStyle(window.__shaderCtx, newStyle);
        } else {
          try {
            window.__shaderCtx = initShader(shaderCanvas, newStyle);
            setShaderIdle(window.__shaderCtx);
          } catch (e) {
            console.warn('Shader initialization failed:', e);
          }
        }
      }
    }

    // Cycle through background visualization styles
    const vizStyles = ['none', 'orbs', 'stars', 'trails'];

    function cycleBackgroundViz(direction: number) {
      const currentIndex = vizStyles.indexOf(currentVizStyle);
      let newIndex = currentIndex + direction;

      // Wrap around
      if (newIndex < 0) newIndex = vizStyles.length - 1;
      if (newIndex >= vizStyles.length) newIndex = 0;

      const newStyle = vizStyles[newIndex];

      // Update dropdown active state
      vizButtons.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.viz === newStyle);
      });
      currentVizStyle = newStyle;
      vizBtn.classList.toggle('active', newStyle !== 'none');

      if (newStyle === 'none') {
        // Cleanup shader
        if (window.__shaderCtx) {
          cleanupShader(window.__shaderCtx);
          window.__shaderCtx = undefined;
          const gl = shaderCanvas.getContext('webgl2');
          if (gl) {
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);
          }
        }
      } else {
        // Initialize or switch style
        if (window.__shaderCtx) {
          setShaderStyle(window.__shaderCtx, newStyle);
        } else {
          try {
            window.__shaderCtx = initShader(shaderCanvas, newStyle);
            setShaderIdle(window.__shaderCtx);
          } catch (e) {
            console.warn('Shader initialization failed:', e);
          }
        }
      }
    }

    // Toggle audio visualizers (spectrum, scope, pianoroll)
    function toggleAudioVisualizers() {
      audioVizEnabled = !audioVizEnabled;
      audioVizBtn.classList.toggle('active', audioVizEnabled);
      spectrumCanvas.classList.toggle('hidden', !audioVizEnabled);
      scopeCanvas.classList.toggle('hidden', !audioVizEnabled);
      pianorollCanvas.classList.toggle('hidden', !audioVizEnabled);

      // Actually start/stop the animation loops (not just CSS hide)
      if (!isMobile) {
        if (audioVizEnabled && isPlaying) {
          customScope?.start();
          customSpectrum?.start();
        } else {
          customScope?.stop();
          customSpectrum?.stop();
        }
      }
    }

    // Toggle "visuals only" mode - hide UI, enable all visualizers, set background to orbs
    let visualsOnlyMode = false;
    let savedAudioVizState = true;
    let savedVizStyle = 'orbs';

    function toggleVisualsOnlyMode() {
      if (!visualsOnlyMode) {
        // Entering visuals-only mode - save states first
        savedCodeState = !codeSection.classList.contains('hidden');
        savedGenerateState = !generatePanel.classList.contains('hidden');
        savedAlterState = !alterSection.classList.contains('hidden');
        savedAudioVizState = audioVizEnabled;
        savedVizStyle = currentVizStyle;

        // Hide all UI panels
        codeSection.classList.add('hidden');
        generatePanel.classList.add('hidden');
        alterSection.classList.add('hidden');
        codeBtn.classList.remove('active');
        aiBtn.classList.remove('active');
        alterToggleBtn.classList.remove('active');
        panelsVisible = false;

        // Enable audio visualizers
        audioVizEnabled = true;
        audioVizBtn.classList.add('active');
        spectrumCanvas.classList.remove('hidden');
        scopeCanvas.classList.remove('hidden');
        pianorollCanvas.classList.remove('hidden');

        // Set background to "glowing orbs"
        if (currentVizStyle !== 'orbs') {
          vizButtons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.viz === 'orbs');
          });
          currentVizStyle = 'orbs';
          vizBtn.classList.add('active');

          if (window.__shaderCtx) {
            setShaderStyle(window.__shaderCtx, 'orbs');
          } else {
            try {
              window.__shaderCtx = initShader(shaderCanvas, 'orbs');
              setShaderIdle(window.__shaderCtx);
            } catch (e) {
              console.warn('Shader initialization failed:', e);
            }
          }
        }

        visualsOnlyMode = true;
      } else {
        // Exiting visuals-only mode - restore saved states
        if (savedCodeState) {
          codeSection.classList.remove('hidden');
          codeBtn.classList.add('active');
        }
        if (savedGenerateState) {
          generatePanel.classList.remove('hidden');
          aiBtn.classList.add('active');
        }
        if (savedAlterState) {
          alterSection.classList.remove('hidden');
          alterToggleBtn.classList.add('active');
        }
        panelsVisible = savedCodeState || savedGenerateState || savedAlterState;

        // Restore audio visualizers state
        audioVizEnabled = savedAudioVizState;
        audioVizBtn.classList.toggle('active', audioVizEnabled);
        spectrumCanvas.classList.toggle('hidden', !audioVizEnabled);
        scopeCanvas.classList.toggle('hidden', !audioVizEnabled);
        pianorollCanvas.classList.toggle('hidden', !audioVizEnabled);

        // Restore background viz style
        if (savedVizStyle !== currentVizStyle) {
          vizButtons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.viz === savedVizStyle);
          });
          currentVizStyle = savedVizStyle;
          vizBtn.classList.toggle('active', savedVizStyle !== 'none');

          if (savedVizStyle === 'none') {
            if (window.__shaderCtx) {
              cleanupShader(window.__shaderCtx);
              window.__shaderCtx = undefined;
              const gl = shaderCanvas.getContext('webgl2');
              if (gl) {
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
              }
            }
          } else if (window.__shaderCtx) {
            setShaderStyle(window.__shaderCtx, savedVizStyle);
          }
        }

        visualsOnlyMode = false;
      }
    }

    // Handle bank dropdown change - update code and restart playback
    function handleBankChange() {
      const newBank = bankSelect.value;
      const wasPlaying = isPlaying;

      // Stop current playback
      if (isPlaying) {
        stopCode();
      }

      // Get current code and update the bank
      let code = getCode(editor);
      let codeChanged = false;

      if (newBank) {
        if (code.match(/\.bank\("[^"]*"\)/)) {
          // Replace existing bank with new one
          code = code.replace(/\.bank\("[^"]*"\)/, `.bank("${newBank}")`);
          codeChanged = true;
        } else {
          // No .bank() exists - try to add one to the inner drum stack
          // Look for pattern: ) followed by , followed by synth content (// Synths or note()
          const drumStackPattern = /\)(\s*,\s*\n\s*)(\/\/ Synths|note\()/;
          if (code.match(drumStackPattern)) {
            code = code.replace(drumStackPattern, `).bank("${newBank}")$1$2`);
            codeChanged = true;
          }
        }
      } else {
        // Remove .bank() if "Drum machine" (no bank) is selected
        if (code.match(/\.bank\("[^"]*"\)/)) {
          code = code.replace(/\.bank\("[^"]*"\)/, '');
          codeChanged = true;
        }
      }

      // Update the code in editor if changed
      if (codeChanged) {
        setCode(editor, code);
      }

      // Update the stored bank name
      lastBankName = newBank;

      // Restart playback if it was playing
      if (wasPlaying) {
        playCode();
      }
    }

    // Event listeners
    contextHeader.addEventListener('click', toggleContextSection);
    aiBtn.addEventListener('click', toggleGeneratePanel);
    codeBtn.addEventListener('click', toggleCodeSection);
    alterToggleBtn.addEventListener('click', toggleAlterSection);
    generateBtn.addEventListener('click', generateCode);
    alterBtn.addEventListener('click', alterCode);
    evolveBtn.addEventListener('click', toggleEvolution);
    playBtn.addEventListener('click', togglePlay);
    alterPlayBtn.addEventListener('click', togglePlay);
    stopBtn.addEventListener('click', stopCode);
    bankSelect.addEventListener('change', handleBankChange);

    // Share button - copy share link to clipboard
    shareBtn.addEventListener('click', async () => {
      const code = getCode(editor);
      if (!code.trim()) {
        showToast('No code to share');
        return;
      }

      const { url, error } = generateShareUrl(code);
      if (!url) {
        showToast('Failed to generate share link');
        return;
      }

      try {
        await navigator.clipboard.writeText(url);
        if (error) {
          showToast('Link copied! Warning: URL is long', 4000);
        } else {
          showToast('Share link copied!', 2000);
        }
      } catch (err) {
        console.error('Clipboard write failed:', err);
        showToast('Failed to copy link');
      }
    });

    // Toggle visualizer dropdown
    vizBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      vizDropdown.classList.toggle('hidden');
    });

    // Close dropdown when clicking outside
    document.addEventListener('click', () => {
      vizDropdown.classList.add('hidden');
    });

    // Handle visualizer style selection
    vizButtons.forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const newStyle = btn.dataset.viz!;

        // Update active state
        vizButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentVizStyle = newStyle;

        // Update button appearance
        vizBtn.classList.toggle('active', newStyle !== 'none');

        // Close dropdown
        vizDropdown.classList.add('hidden');

        if (newStyle === 'none') {
          // Cleanup shader when switching to "No vis"
          if (window.__shaderCtx) {
            cleanupShader(window.__shaderCtx);
            window.__shaderCtx = undefined;
            // Clear the canvas
            const gl = shaderCanvas.getContext('webgl2');
            if (gl) {
              gl.clearColor(0, 0, 0, 0);
              gl.clear(gl.COLOR_BUFFER_BIT);
            }
          }
        } else if (window.__shaderCtx) {
          // Switch between styles
          setShaderStyle(window.__shaderCtx, newStyle);
        } else {
          // Initialize shader when switching from "No vis" to a style
          try {
            window.__shaderCtx = initShader(shaderCanvas, newStyle);
            setShaderIdle(window.__shaderCtx);
          } catch (e) {
            console.warn('Shader initialization failed:', e);
          }
        }
      });
    });

    // Toggle audio visualizers (spectrum, scope, pianoroll)
    audioVizBtn.addEventListener('click', () => {
      audioVizEnabled = !audioVizEnabled;
      audioVizBtn.classList.toggle('active', audioVizEnabled);
      spectrumCanvas.classList.toggle('hidden', !audioVizEnabled);
      scopeCanvas.classList.toggle('hidden', !audioVizEnabled);
      pianorollCanvas.classList.toggle('hidden', !audioVizEnabled);
    });

    alterInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        alterCode();
      }
    });

    promptInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        generateCode();
      }
    });

    // Info button and shortcuts popup
    const infoBtn = document.getElementById('info-btn') as HTMLButtonElement;
    const shortcutsPopup = document.getElementById('shortcuts-popup') as HTMLDivElement;
    const shortcutsClose = document.getElementById('shortcuts-close') as HTMLButtonElement;

    // Stats button and token popup
    const statsBtn = document.getElementById('stats-btn') as HTMLButtonElement;
    const tokenPopup = document.getElementById('token-popup') as HTMLDivElement;
    const tokenPopupClose = document.getElementById('token-popup-close') as HTMLButtonElement;

    function toggleShortcutsPopup(e: Event) {
      e.stopPropagation();
      shortcutsPopup.classList.toggle('hidden');
      // Close token popup when opening shortcuts
      tokenPopup.classList.add('hidden');
    }

    function toggleTokenPopup(e: Event) {
      e.stopPropagation();
      tokenPopup.classList.toggle('hidden');
      // Close shortcuts popup when opening token popup
      shortcutsPopup.classList.add('hidden');
    }

    infoBtn.addEventListener('click', toggleShortcutsPopup);
    shortcutsClose.addEventListener('click', toggleShortcutsPopup);
    statsBtn.addEventListener('click', toggleTokenPopup);
    tokenPopupClose.addEventListener('click', toggleTokenPopup);

    // Reset tokens button
    const resetTokensBtn = document.getElementById('reset-tokens') as HTMLButtonElement;
    resetTokensBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      resetTokenTotals();
    });

    // Close popups when clicking/tapping outside
    document.addEventListener('click', (e) => {
      if (!shortcutsPopup.classList.contains('hidden') &&
          !shortcutsPopup.contains(e.target as Node) &&
          !infoBtn.contains(e.target as Node)) {
        shortcutsPopup.classList.add('hidden');
      }
      if (!tokenPopup.classList.contains('hidden') &&
          !tokenPopup.contains(e.target as Node) &&
          !statsBtn.contains(e.target as Node)) {
        tokenPopup.classList.add('hidden');
      }
    });

    // Keyboard shortcut: K to toggle play/pause
    document.addEventListener('keydown', (e) => {
      // Don't trigger if typing in an input field or the code editor
      if (e.target instanceof HTMLInputElement ||
          e.target instanceof HTMLTextAreaElement ||
          editorContainer.contains(e.target as Node)) {
        return;
      }

      if (e.key === 'k' || e.key === 'K') {
        e.preventDefault();
        togglePlay();
      }

      // H to hide/show all panels
      if (e.key === 'h' || e.key === 'H') {
        e.preventDefault();
        toggleAllPanels();
      }

      // V to toggle audio visualizers
      if (e.key === 'v' || e.key === 'V') {
        e.preventDefault();
        toggleAudioVisualizers();
      }

      // B to toggle between "no vis" and "glowing orbs"
      if (e.key === 'b' || e.key === 'B') {
        e.preventDefault();
        toggleBackgroundVis();
      }

      // A to toggle "visuals only" mode
      if (e.key === 'a' || e.key === 'A') {
        e.preventDefault();
        toggleVisualsOnlyMode();
      }

      // < to select previous background effect
      if (e.key === '<' || e.key === ',') {
        e.preventDefault();
        cycleBackgroundViz(-1);
      }

      // > to select next background effect
      if (e.key === '>' || e.key === '.') {
        e.preventDefault();
        cycleBackgroundViz(1);
      }

      // Escape to close popups
      if (e.key === 'Escape') {
        shortcutsPopup.classList.add('hidden');
        tokenPopup.classList.add('hidden');
      }
    });

    // Initialize on load
    init();

    // Show toast if code was loaded from shared URL
    if (sharedCode) {
      showToast('Loaded shared code!', 2000);
    }

    // Mobile: use lightweight visualizers (only pianoroll, no background effects)
    if (isMobile) {
      // Disable background effects
      currentVizStyle = 'none';
      vizBtn.classList.remove('active');
      vizButtons.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.viz === 'none');
      });

      // Hide scope and spectrum, keep only pianoroll
      scopeCanvas.classList.add('hidden');
      spectrumCanvas.classList.add('hidden');
      pianorollCanvas.classList.remove('hidden');
    } else {
      // Desktop: Initialize shader on page load if a style is selected
      if (currentVizStyle !== 'none') {
        try {
          window.__shaderCtx = initShader(shaderCanvas, currentVizStyle);
          setShaderIdle(window.__shaderCtx);
          vizBtn.classList.add('active');
        } catch (e) {
          console.warn('Shader initialization failed:', e);
        }
      }
    }
  </script>
</Layout>
